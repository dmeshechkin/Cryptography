Задание 1
Файл 1.txt зашифрован с помощью AES-128 в режиме ECB на ключе YELLOW SUBMARINE и закодирован в base64. 
Примечание: буквы ключа заглавные, длина ровно 16 символов (байт) - замечательный ключ для AES-128.

Дешифруйте файл. В конце концов у вас есть ключ. Проще всего использовать OpenSSL::Cipher в режиме AES-128-ECB, но это не наш путь. 
Мы должны реализовать режим ECB сами, это пригодится нам в дальнейшем.

Хорошая новость в том, что для этого не нужно писать AES-128 с нуля. Мы сделаем AES-128 из подручных средств. 
На Python функция дешифрования будут выглядеть примерно так:

```
def aes128_decrypt(block, key):
if len(block) != 16:
return None

cipher = AES.new(key, AES.MODE_ECB)
return cipher.decrypt(block)
[]()
http://cryptopals.com/sets/1/challenges/7
[]()
**Задание 2**
В файле 2.txt находится несколько шифротекстов. Один из них был зашифрован в режиме ECB. Найдите его.
[]()
Помните, в чем основная проблема режима ECB? Одинаковые 16 байт открытого текста дают одинаковые 16 байт шифротекста.
[]()
http://cryptopals.com/sets/1/challenges/8
[]()
**Задание 3**
Реализуйте PKCS#7 паддинг, который будет дополнять блок до заданной длины. У вас должна получиться функция `pkcs7_padding(block, target_length)`.
[]()
Для примера, `pkcs7_padding(“YELLOW SUBMARINE”, 20)` вернет `YELLOW SUBMARINE\x04\x04\x04\x04`.
[]()
http://cryptopals.com/sets/2/challenges/9
[]()
**Задание 4**
Реализуйте функции шифрования и дешифрования AES-128 в режиме CBC (используйте код из задания 1). Дешифруйте файл 4.txt с помощью ключа `YELLOW SUBMARINE` и вектора инициализации, состоящего из нулей `\x00\x00\x00...`.
[]()
http://cryptopals.com/sets/2/challenges/10
[]()
**Задание 5**
К этому моменту у вас должны быть готовы ECB и CBC режимы AES.
[]()
Напишите функцию, которая генерирует случайный ключ (16 байт из /dev/urandom).
[]()
Напишите функцию, которая берет случайный ключ и шифрует с его помощью открытый текст. Функция будет выглядеть как `encryption_oracle(your-input)` и возвращать шифротекст.
[]()
Также функция-оракул должна присоединять 5-10 (число выбирается случайно) рандомных байт перед открытым текстом и 5-10 рандомных байт после открытого текста.
[]()
Пусть функция-оракул в половине случаев шифрует в режиме ECB, а в другой половине случаев в режиме CBC (режим выбирается случайным образом).
[]()
Вам нужно написать программу, которая примет на вход шифротекст и будет способна определить какой из режимов шифрования был использован (ECB или CBC). Примечание: вы можете подавать на вход функции-оракула открытый текст произвольной длины.
[]()
http://cryptopals.com/sets/2/challenges/11
[]()
**Задание 6**
Модифицируйте функцию `encryption_oracle` из задания 5 так, чтобы она шифровала только в режиме ECB на случайном ключе, который остается одинаковым в пределах запуска программы (например, сделайте глобальную переменную KEY и берите значение из os.urandom).
[]()
Функция будет добавлять к открытому тексту base64-декодированное значение (это нужно сделать до шифрования):
[]()
Um9sbGluJyBpbiBteSA1LjAKV2l0aCBteSByYWctdG9wIGRvd24gc28gbXkg
aGFpciBjYW4gYmxvdwpUaGUgZ2lybGllcyBvbiBzdGFuZGJ5IHdhdmluZyBq
dXN0IHRvIHNheSBoaQpEaWQgeW91IHN0b3A/IE5vLCBJIGp1c3QgZHJvdmUg
YnkK

[]()
Внимание! Не декодируйте это значение. Суть задания в том, что вы не знаете что внутри base64.
[]()
В итоге ваша функция будет возвращать значение:
[]()

AES-128-ECB(ваша-строка || неизвестная-строка, случайный-ключ)
```

В такой схеме вы можете восстановить содержимое неизвестной строки, сделав несколько запросов к функции-ораклу! Алгоритм выглядит примерно так:

Шаг 1. Узнайте размер блока (вы уже его знаете, но все равно выполните этот шаг). Для этого подавайте на вход строки из одинаковых байт, каждый раз добавляя по одному байте: “A”, “AA”, “AAA” и так далее. Подумайте о том, в какой момент вы сможете точно определить длину блока.

Шаг 2. Поймите, что функция использует ECB режим шифрования. Вам это уже известно, но все равно выполните этот шаг.

Шаг 3. Создайте блок данных, длина которого в точности на единицу меньше длины блока (например, если длина блока 8, то блок данных будет “AAAAAAA”). Задайтесь вопросом: что функция шифрования поставит на позицию последнего байта?

Шаг 4. Подавайте на вход функции-оракула все возможные значения последнего байта (“AAAAAAAA”, “AAAAAAAB”, “AAAAAAAC” и так далее). Запомните первый блок каждого получившегося шифротекста.

Шаг 5. Возьмите блок шифротекста из шага 3 и найдите его в списке из шага 4. Теперь вы знаете первый байт неизвестной строки.

Шаг 6. Повторите алгоритм для второго и последующих байт.

http://cryptopals.com/sets/2/challenges/12